### 随记

#### C++ 不允许将临时对象绑定到非常量左值引用

```c++
std::string& ref = std::string("temp"); // ❌ 不允许
const std::string& ref = std::string("temp"); // ✅ 允许

```





#### c++ 设置对象只可移动，不能复制

> 若对象只可移动不能复制，使用std::move(obj)

>  在 C++ 中，有几种方法可以创建 **只能移动（move-only)** 的对象，即：
>
> - 可以通过 **移动构造函数** 和 **移动赋值运算符** 转移所有权
> - 不能通过 **拷贝构造函数** 和 **拷贝赋值运算符** 复制

```cpp
class MoveOnly {
public:
    MoveOnly() = default;
    
    // 移动构造函数
    MoveOnly(MoveOnly&&) = default;
    
    // 移动赋值运算符
    MoveOnly& operator=(MoveOnly&&) = default;
    
    // 删除拷贝构造和拷贝赋值
    MoveOnly(const MoveOnly&) = delete;
    MoveOnly& operator=(const MoveOnly&) = delete;
};
```





#### C++ 完美转发

**完美转发（Perfect Forwarding）** 的核心是：**在函数模板中，将参数“原封不动”地转发给另一个函数，既保持参数的左/右值属性，也保持其 const/volatile 等限定符**，就像直接调用目标函数一样。


为什么需要完美转发？
举个生活例子：你帮朋友带一份快递，朋友叮嘱“要轻拿轻放（右值，临时对象）”，结果你转交时没说明，对方按“普通包裹（左值，持久对象）”扔着处理——这就破坏了原有的“属性”。  
C++ 中，如果没有完美转发，模板函数传递参数时，左值可能被转为右值，const 可能被丢失，导致目标函数调用错误或性能浪费（比如本该移动的变成了拷贝）。


如何实现完美转发？
依赖两个关键技术，缺一不可：
1.  **万能引用（Universal Reference）**：语法为 `T&&`，但仅在 **模板参数推导** 场景下生效（如 `template <typename T> void func(T&& param)`）。它能“接收”任何类型的参数（左值或右值），并根据参数类型推导自身是左值引用还是右值引用。
    - 当传入左值（如 `int a; func(a)`），`T` 推导为 `int&`，`T&&` 折叠为 `int&`（左值引用）。
    - 当传入右值（如 `func(10)`），`T` 推导为 `int`，`T&&` 就是 `int&&`（右值引用）。
2.  **`std::forward` 函数**：用于“还原”万能引用的原始类型。它只对用 `T&&` 接收的参数生效，根据 `T` 的推导结果，将参数转发为左值或右值。
    - 若 `T` 是左值引用（如传入左值），`std::forward<T>(param)` 转发为左值。
    - 若 `T` 是非引用类型（如传入右值），`std::forward<T>(param)` 转发为右值。


用代码理解：完美转发 vs 普通转发
假设我们有两个目标函数，分别接收左值和右值：
```cpp
// 接收左值
void target(int& x) {
    cout << "左值引用: " << x << endl;
}

// 接收右值
void target(int&& x) {
    cout << "右值引用: " << x << endl;
}
```

1. 普通转发（失败案例）
如果不用完美转发，模板函数无法保持参数属性：
```cpp
template <typename T>
void bad_forward(T param) {  // 按值传递，会拷贝，且丢失左/右值属性
    target(param);  // param 是变量（左值），永远调用 target(int&)
}

int a = 10;
bad_forward(a);    // 传入左值，调用 target(int&) → 看似对，但拷贝了参数
bad_forward(20);   // 传入右值，但 param 是左值，仍调用 target(int&) → 错误！
```


2. 完美转发（成功案例）
用万能引用 + `std::forward` 实现：
```cpp
template <typename T>
void perfect_forward(T&& param) {  // 万能引用，接收左/右值
    target(std::forward<T>(param));  // 完美转发，还原原始类型
}

int a = 10;
perfect_forward(a);    // 传入左值，T推导为int&，forward转发为左值 → 调用 target(int&)
perfect_forward(20);   // 传入右值，T推导为int，forward转发为右值 → 调用 target(int&&)
```
这就实现了“原封不动”的转发，和直接调用 `target(a)`、`target(20)` 的效果完全一致。


核心总结
- **完美转发 = 万能引用（`T&&`） + `std::forward<T>`**，二者必须配合使用。
- 目的：解决模板函数中参数传递时“属性丢失”的问题，确保目标函数能正确匹配左/右值重载。
- 记忆点：万能引用负责“接收所有类型”，`std::forward` 负责“还原原始类型”，像快递中转站一样，原样传递包裹的“易碎（右值）”或“普通（左值）”标签。





#### C++ 左值和右值

1. 左值-能放在赋值号左边的东西
假设你有个杯子，杯子里装着水。现在我问你：**“你能把‘水’倒进‘杯子’里，还是能把‘杯子’倒进‘水’里？”**  
答案显然是前者——因为「杯子」是一个「有固定位置、能被“装东西”」的容器；而「水」是「没有固定位置、倒出去就可能消失」的东西。

C++ 里的「左值」，就相当于这个「杯子」。它的核心特点是：**有自己的“内存地址”，能被赋值（放在 `=` 左边），也能被反复修改**。

举个最直观的例子：
```cpp
int a = 10;  // 这里的 a 就是左值
a = 20;      // 能再次赋值，没问题（杯子能重新装水）
```
为什么 `a` 是左值？因为 `a` 是一个「变量」——它在内存里占了一块固定的地方（比如地址 `0x1234`），我们能往这块地方里塞不同的数字（10、20……）。

再想一个场景：如果你有个函数返回「变量本身」，它也是左值。比如：
```cpp
int& get_num(int& x) {  // 返回值是“引用”（可以理解为“杯子的别名”）
    return x;
}

int b = 5;
get_num(b) = 100;  // 没问题！get_num(b) 返回的是 b 的别名（还是杯子），能放左边赋值
```
这里 `get_num(b)` 本质还是 `b` 这个“杯子”，所以它是左值。


2 右值-只能放在赋值号右边的东西
回到杯子的例子：「水」不能当容器，只能被“装进杯子”。C++ 里的「右值」，就相当于这「水」——它的核心特点是：**没有固定内存地址（或者说“临时存在”），不能被赋值（放 `=` 左边会报错），用完就可能被销毁**。

最典型的右值是「字面量」（比如 `10`、`3.14`、`"hello"`）：
```cpp
int c = 10;  // 这里的 10 就是右值
10 = 20;     // 报错！你不能把 20 塞进“10”里（水不能当杯子）
```
为什么 `10` 是右值？因为 `10` 不是变量——它是一个“临时的数值”，程序用它的时候，可能只在 CPU 寄存器里暂存一下，用完就没了，根本没有固定的内存地址，自然不能被赋值。

另一种常见的右值是「函数返回的临时值」：
```cpp
int add(int x, int y) {
    return x + y;  // 返回的是 x+y 的结果（临时值，不是变量）
}

int d = add(3, 5);  // 没问题！add返回的临时值（8）是右值，能放右边赋值
add(3, 5) = 10;     // 报错！临时值是右值，不能放左边
```
`add(3,5)` 计算出的 `8` 是个临时结果，不是任何变量，所以是右值，不能被赋值。

3. 区分左值和右值
前面的例子其实能总结出一个最简单的判断方法：**如果一个东西能被 `&`（取地址符）取到地址，它就是左值；反之就是右值**。

我们来验证一下：
- 左值 `a`：`&a` 能拿到地址（比如 `0x1234`）→ 左值。
- 右值 `10`：`&10` 会报错（临时值没有固定地址）→ 右值。
- 左值 `get_num(b)`：`&get_num(b)` 其实是 `&b`，能拿到地址 → 左值。
- 右值 `add(3,5)`：`&add(3,5)` 会报错（临时结果没地址）→ 右值。

这个测试几乎能覆盖 90% 的场景，记不住定义的时候，用它判断就够了。

4. 为什么要区分左值和右值？  
**为了“高效”和“安全”**——C++11 之后引入的「右值引用」（`&&`），就是基于左值和右值的区分，解决了“临时对象拷贝浪费性能”的问题。

举个例子：假设你有个函数返回一个很大的字符串（比如 10MB）：
```cpp
string get_big_string() {
    string temp = "非常长的字符串...";  // 临时对象 temp
    return temp;  // 返回 temp 的拷贝（传统方式会复制 10MB 数据，很慢）
}
```
在 C++11 之前，`get_big_string()` 返回的 `temp` 是右值（临时值），但程序会把它“拷贝”一份给接收变量，10MB 的数据拷贝一次很浪费。

但有了右值引用后，程序会发现：“哦，这个临时值（右值）用完就要销毁了，不如直接把它的‘资源’（内存）‘偷’过来用，不用拷贝了！” 这就是「移动语义」，能大幅提升性能。

而要实现“移动语义”，前提就是能区分「右值」（可以偷资源的临时对象）和「左值」（不能偷，否则原变量就废了）——这就是左值和右值区分的核心价值。

**总结**

- **左值**：是“容器”（有地址、能赋值、能取地址），比如变量、引用。
- **右值**：是“内容”（没地址、不能赋值、不能取地址），比如字面量、临时值。
- **判断口诀**：能取地址的是左值，不能的是右值。





#### **void***

在 C++ 中，`void*` 被称为“无类型指针”或“万能指针”，它可以指向任何类型的数据（包括基本类型、自定义类型、数组等），但不包含所指向数据的类型信息。这一特性使得它在需要处理未知类型数据的场景中非常灵活，但也带来了类型安全方面的风险。


**主要特性**
1. **可以指向任何类型的数据**  
   无需显式类型转换，`void*` 可以直接指向任意类型的变量或对象：
   ```cpp
   int a = 10;
   double b = 3.14;
   void* ptr;
   
   ptr = &a;  // 合法：void* 指向 int 类型
   ptr = &b;  // 合法：void* 指向 double 类型
   ```

2. **不能直接解引用**  
   由于 `void*` 不包含类型信息，无法直接通过 `*` 解引用获取数据，必须先强制转换为具体类型的指针：
   ```cpp
   int a = 10;
   void* ptr = &a;
   
   // *ptr;  // 错误：无法直接解引用 void*
   int* int_ptr = static_cast<int*>(ptr);  // 强制转换为 int*
   std::cout << *int_ptr;  // 正确：输出 10
   ```

3. **不能进行算术运算**  
   指针算术运算（如 `+`、`-`）依赖于指针指向的数据类型大小，而 `void*` 无类型信息，因此不支持算术运算：
   ```cpp
   void* ptr;
   // ptr++;  // 错误：void* 不支持算术运算
   ```

4. **作为函数参数/返回值**  
   常用于需要处理多种类型数据的函数（如内存操作函数 `malloc`、`memcpy` 等）：
   ```cpp
   // 示例：交换两个任意类型变量的值（需传入数据大小）
   void swap(void* a, void* b, size_t size) {
       char temp[size];  // 临时缓冲区（C++11 起支持变长数组）
       memcpy(temp, a, size);
       memcpy(a, b, size);
       memcpy(b, temp, size);
   }
   
   // 使用：
   int x = 1, y = 2;
   swap(&x, &y, sizeof(int));  // 正确交换 int
   ```


**注意事项**
- **类型安全风险**：使用 `void*` 时，程序员必须确保强制转换的类型与原数据类型一致，否则会导致未定义行为（如访问错误数据）。
- **C++ 中的替代方案**：在很多场景下，模板（`template`）可以更安全地实现泛型编程，避免 `void*` 的类型风险，因此 C++ 中应优先使用模板而非 `void*`。
- **与 `const` 的交互**：`void*` 不能直接指向 `const` 类型的数据，需使用 `const void*`：
  ```cpp
  const int a = 10;
  // void* ptr = &a;  // 错误：不能将 const int* 隐式转为 void*
  const void* cptr = &a;  // 正确：const void* 可指向 const 类型
  ```

总结：`void*` 提供了灵活性，但牺牲了类型安全，使用时需谨慎确保类型匹配。在 C++ 中，优先考虑模板或其他类型安全的泛型方案。



#### float**

在 C++ 中，`float**` 表示“指向 float 指针的指针”，也称为“二级指针”。它是一种嵌套指针类型，用于间接指向 `float` 类型的数据。

**理解层级关系**
可以通过“指针指向的对象类型”来拆解：
- `float*`：一级指针，指向一个 `float` 类型的变量（直接存储 `float` 数据的地址）。
- `float**`：二级指针，指向一个 `float*` 类型的指针（即存储“一级指针的地址”）。

示意图如下：
```
float  value;       // 实际的 float 数据（例如：3.14）
float* ptr = &value;  // 一级指针：指向 value 的地址
float**pptr = &ptr;   // 二级指针：指向 ptr 的地址
```

此时，通过 `float**` 访问最终的 `float` 数据需要两次解引用：
```cpp
float value = 3.14f;
float* ptr = &value;
float** pptr = &ptr;

// 访问 value 的三种方式：
cout << value << endl;       // 直接访问：3.14
cout << *ptr << endl;        // 一级解引用：3.14
cout << **pptr << endl;      // 二级解引用：3.14
```


**常见用途**
1.** 指向动态二维数组 **`float**` 常用于表示动态分配的二维浮点数组（行数和列数在运行时确定）。例如：
   ```cpp
   int rows = 2, cols = 3;
   // 步骤1：分配存储行指针的数组（float* 类型的数组）
   float** matrix = new float*[rows];
   // 步骤2：为每行分配列数据（float 类型的数组）
   for (int i = 0; i < rows; i++) {
       matrix[i] = new float[cols];
   }

   // 使用：给二维数组赋值
   matrix[0][0] = 1.1f;
   matrix[0][1] = 1.2f;
   // ...

   // 释放内存（先释放每行，再释放行指针数组）
   for (int i = 0; i < rows; i++) {
       delete[] matrix[i];
   }
   delete[] matrix;
   ```

2. **函数中修改一级指针的值**  
   如果需要在函数内部修改外部的一级指针（例如重新分配内存），需通过二级指针传递其地址。例如：
   ```cpp
   // 函数：为外部的 float* 分配内存并赋值
   void allocateFloat(float** ptr, float value) {
       *ptr = new float;  // 修改外部指针的指向（需解引用二级指针）
       **ptr = value;     // 给最终的 float 赋值（二次解引用）
   }
   
   // 使用
   float* num = nullptr;
   allocateFloat(&num, 5.5f);  // 传递一级指针的地址（&num 是 float** 类型）
   cout << *num << endl;       // 输出 5.5
   delete num;
   ```

**注意事项**
- **多级指针的复杂度**：`float**` 是二级指针，还可以有 `float***`（三级指针）等，但层级越多越难维护，需谨慎使用。
- **内存管理**：如果用于动态数组，需严格按照“先分配的后释放”的顺序释放内存，避免内存泄漏。
- **与数组的区别**：`float**` 表示的是“指针的指针”，而 `float[2][3]` 是编译期确定的二维数组（内存连续），二者内存布局不同，不能直接混用。

总之，`float**` 是通过两层间接引用访问 `float` 数据的指针类型，核心用途是处理动态二维数组或在函数中修改一级指针。







#### new的使用场景

场景2的核心是「**多态行为的实现依赖动态内存分配**」——这是C++中最常见也最核心的`new`使用场景之一。我们需要从「多态的本质要求」、「栈对象为什么无法满足」、「动态分配如何解决」、「实战细节」四个层面，一步步把逻辑讲透。

**先铺垫：多态的核心前提**
要理解场景2，首先得明确C++多态的两个必要条件（缺一不可）：

1. **基类有虚函数**（`virtual` 修饰的成员函数，如 `virtual void func()`），派生类重写（`override`）该虚函数；
2. **通过「基类指针/引用」调用虚函数**——只有这样，编译器才会在运行时根据指针/引用实际指向的「派生类对象」，调用对应的重写函数（而非编译时绑定基类函数）。

而场景2的关键矛盾是：**栈上的派生类对象，无法通过基类指针/引用实现完整多态（会发生「对象切片」）**，必须通过`new`在堆上创建派生类对象，才能保留多态特性。


**第一步：为什么栈对象无法实现多态？（对象切片问题**
我们先看一个「用栈对象尝试多态」的错误示例，直观感受问题：
```cpp
#include <iostream>
using namespace std;

// 基类
class Base {
public:
    // 虚函数（多态的核心）
    virtual void show() {
        cout << "我是基类 Base" << endl;
    }
    // 析构函数必须为虚函数（后续解释）
    virtual ~Base() {
        cout << "Base 析构" << endl;
    }
};

// 派生类（继承 Base）
class Derived : public Base {
public:
    // 重写基类的虚函数（override 显式声明，可选但推荐）
    void show() override {
        cout << "我是派生类 Derived" << endl;
    }
    ~Derived() override {
        cout << "Derived 析构" << endl;
    }
};

// 尝试返回栈上的派生类对象（错误示范）
Base returnPolymorphicObj() {
    Derived derived_obj; // 栈上创建派生类对象
    return derived_obj;  // 返回时，将派生类对象赋值给基类对象（发生切片）
}

int main() {
    Base base_ptr = returnPolymorphicObj(); // 基类对象接收返回值
    base_ptr.show(); // 期望输出「我是派生类 Derived」，实际输出「我是基类 Base」
    return 0;
}
```
**运行结果（不符合预期）**
```
我是基类 Base
Base 析构
Base 析构
```

**问题核心：对象切片（Object Slicing）**
当你把「派生类对象」赋值给「基类对象」时（无论是返回值、直接赋值），C++ 会执行「切片拷贝」：
- 只拷贝基类部分的成员（派生类独有的成员会被「切掉」）；
- 最终得到的是一个「纯基类对象」，而非派生类对象——因此调用 `show()` 时，只会执行基类的版本，多态特性完全丢失。

更致命的是：即使你用「基类指针指向栈上的派生类对象」，也会有生命周期问题：
```cpp
// 更危险的错误示范：返回栈对象的指针
Base* returnStackObjPtr() {
    Derived derived_obj; // 栈对象，函数结束后立即析构
    return &derived_obj; // 返回栈对象的地址（函数结束后指针悬空）
}

int main() {
    Base* base_ptr = returnStackObjPtr(); // 悬空指针（指向已析构的对象）
    base_ptr->show(); // 未定义行为（可能崩溃、输出乱码）
    return 0;
}
```
- 栈对象 `derived_obj` 在函数返回时就析构了，基类指针 `base_ptr` 变成「悬空指针」，后续访问是未定义行为（UB），程序可能崩溃。


** 第二步：动态分配（new）如何解决多态问题？**
动态分配的核心作用是：**让派生类对象在堆上创建，生命周期不依赖函数作用域，且能通过基类指针完整指向派生类对象（无切片）**。

我们改写上面的代码，用`new`实现正确的多态：
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() {
        cout << "我是基类 Base" << endl;
    }
    virtual ~Base() { // 必须为虚析构（关键！）
        cout << "Base 析构" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "我是派生类 Derived" << endl;
    }
    ~Derived() override {
        cout << "Derived 析构" << endl;
    }
};

// 返回堆上创建的派生类对象（基类指针接收）
Base* returnPolymorphicPtr() {
    // 堆上创建派生类对象，返回基类指针（多态的核心：基类指针指向派生类对象）
    return new Derived(); 
}

int main() {
    Base* base_ptr = returnPolymorphicPtr(); // 基类指针指向堆上的 Derived 对象
    base_ptr->show(); // 运行时绑定：调用 Derived 的 show()，输出符合预期
    
    delete base_ptr; // 释放堆内存（必须手动调用，且依赖虚析构）
    return 0;
}
```

运行结果（符合预期）：
```
我是派生类 Derived
Derived 析构
Base 析构
```

**关键逻辑拆解**
1. **堆对象的生命周期独立**：`new Derived()` 在堆上创建对象，生命周期不随 `returnPolymorphicPtr()` 函数结束而销毁，只有调用 `delete` 才会析构——避免了栈对象的悬空指针问题；
2. **无对象切片**：返回的是「基类指针」，指针本身不存储对象数据，只是指向堆上的 `Derived` 对象（完整保留派生类的所有成员和虚函数表）；
3. **运行时多态**：通过基类指针 `base_ptr` 调用虚函数 `show()` 时，编译器会在运行时查找 `Derived` 对象的虚函数表，调用派生类的重写版本——这就是多态的核心；
4. **虚析构的必要性**：如果基类析构函数不是虚函数，`delete base_ptr` 只会调用基类的析构函数，堆上的 `Derived` 对象部分无法释放，导致「内存泄漏」（派生类独有的成员、堆内存不会被释放）。


**第三步：进阶优化：用智能指针替代裸指针（推荐）**
上面的代码用了裸指针 `Base*`，需要手动 `delete`，存在内存泄漏风险（比如忘记 `delete`、中间抛出异常跳过 `delete`）。C++11 后推荐用「智能指针」（`std::unique_ptr`/`std::shared_ptr`）自动管理堆内存，避免手动操作。

用 `std::unique_ptr` 实现（独占所有权，最常用）
```cpp
#include <iostream>
#include <memory> // 包含智能指针头文件
using namespace std;

class Base {
public:
    virtual void show() { cout << "我是基类 Base" << endl; }
    virtual ~Base() { cout << "Base 析构" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "我是派生类 Derived" << endl; }
    ~Derived() override { cout << "Derived 析构" << endl; }
};

// 返回 unique_ptr<Base>，独占所有权
unique_ptr<Base> returnPolymorphicSmartPtr() {
    // 直接返回堆上的 Derived 对象（智能指针自动管理）
    return make_unique<Derived>(); // 推荐用 make_unique，比 new 更安全
}

int main() {
    // 智能指针自动接收，无需手动 new/delete
    unique_ptr<Base> base_smart_ptr = returnPolymorphicSmartPtr();
    base_smart_ptr->show(); // 多态行为正常
    
    // 无需手动 delete，智能指针在作用域结束时自动析构（调用虚析构）
    return 0;
}
```

**优势**
- 零内存泄漏风险：智能指针在生命周期结束时（如 `main` 函数退出）自动调用 `delete`，即使中间抛出异常也能保证释放；
- 无需手动管理：不用关心 `delete` 的时机，避免裸指针的人为失误；
- 保留多态特性：`unique_ptr<Base>` 本质还是基类指针，指向堆上的 `Derived` 对象，多态行为不受影响。

**第四步：场景2的核心适用场景（什么时候必须这么用？）**
当你需要「同一接口处理不同派生类对象」时，就必须用「基类指针/引用 + 堆上派生类对象」的组合，典型场景包括：
1. **工厂模式**：根据不同参数创建不同派生类对象，返回基类指针（最经典的多态场景）；
   ```cpp
   // 工厂函数：根据类型创建不同的派生类对象
   unique_ptr<Base> createObj(const string& type) {
       if (type == "derived") {
           return make_unique<Derived>();
       } else if (type == "another") {
           return make_unique<AnotherDerived>(); // 另一个派生类
       }
       return make_unique<Base>();
   }
   ```
2. **容器存储多态对象**：用容器（如 `vector`）存储基类指针，实现不同派生类对象的批量管理；
   ```cpp
   vector<unique_ptr<Base>> obj_list;
   obj_list.push_back(make_unique<Derived>());
   obj_list.push_back(make_unique<AnotherDerived>());
   
   // 批量调用，自动适配不同派生类
   for (auto& obj : obj_list) {
       obj->show(); // 分别调用 Derived 和 AnotherDerived 的 show()
   }
   ```
3. **跨作用域共享多态对象**：派生类对象需要在多个函数间传递、共享，且生命周期不确定（用 `std::shared_ptr` 实现共享所有权）。


**场景2的关键注意事项（避坑重点）**
1. **基类析构函数必须是虚函数**：这是多态场景的铁律！否则 `delete` 基类指针时会导致派生类部分内存泄漏；
2. **优先用智能指针，拒绝裸指针**：除非有特殊兼容需求，否则一律用 `unique_ptr`/`shared_ptr`，避免手动管理内存的风险；
3. **不要返回栈对象的指针/引用**：栈对象生命周期随作用域结束，返回其地址会导致悬空指针，触发未定义行为；
4. **对象切片是多态的天敌**：只要是「基类对象接收派生类对象」（而非指针/引用），就会发生切片，多态失效——这是语法特性，无法避免，只能通过指针/引用规避。

**总结场景2的核心逻辑**
- 多态的本质是「基类指针/引用指向派生类对象，调用虚函数时动态绑定」；
- 栈上的派生类对象要么被切片（赋值给基类对象），要么导致悬空指针（返回地址），无法实现有效多态；
- `new` 的核心作用是在堆上创建派生类对象，让其生命周期独立于函数作用域，且能通过基类指针完整保留派生类特性；
- 实际开发中，用「智能指针 + 动态分配」是实现多态的标准、安全方案，裸指针仅在特殊场景使用。

简单说：**多态依赖「基类指针 + 堆派生对象」，而堆对象的创建必须用 `new`（或智能指针的 `make_unique`/`make_shared`，本质也是封装了 `new`）**——这是场景2必须用 `new` 的根本原因。
