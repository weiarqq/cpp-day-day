### 随记

C++ 不允许将临时对象绑定到非常量左值引用

```c++
std::string& ref = std::string("temp"); // ❌ 不允许
const std::string& ref = std::string("temp"); // ✅ 允许

```



c++ 如何设置对象只可移动，不能复制,若对象只可移动不能复制，使用std::move(obj)

>  在 C++ 中，有几种方法可以创建 ** 只能移动（move-only）** 的对象，即：
>
> - 可以通过 **移动构造函数** 和 **移动赋值运算符** 转移所有权
> - 不能通过 **拷贝构造函数** 和 **拷贝赋值运算符** 复制

```cpp
class MoveOnly {
public:
    MoveOnly() = default;
    
    // 移动构造函数
    MoveOnly(MoveOnly&&) = default;
    
    // 移动赋值运算符
    MoveOnly& operator=(MoveOnly&&) = default;
    
    // 删除拷贝构造和拷贝赋值
    MoveOnly(const MoveOnly&) = delete;
    MoveOnly& operator=(const MoveOnly&) = delete;
};
```



C++ 完美转发

**完美转发（Perfect Forwarding）** 的核心是：**在函数模板中，将参数“原封不动”地转发给另一个函数，既保持参数的左/右值属性，也保持其 const/volatile 等限定符**，就像直接调用目标函数一样。


为什么需要完美转发？
举个生活例子：你帮朋友带一份快递，朋友叮嘱“要轻拿轻放（右值，临时对象）”，结果你转交时没说明，对方按“普通包裹（左值，持久对象）”扔着处理——这就破坏了原有的“属性”。  
C++ 中，如果没有完美转发，模板函数传递参数时，左值可能被转为右值，const 可能被丢失，导致目标函数调用错误或性能浪费（比如本该移动的变成了拷贝）。


如何实现完美转发？
依赖两个关键技术，缺一不可：
1.  **万能引用（Universal Reference）**：语法为 `T&&`，但仅在 **模板参数推导** 场景下生效（如 `template <typename T> void func(T&& param)`）。它能“接收”任何类型的参数（左值或右值），并根据参数类型推导自身是左值引用还是右值引用。
    - 当传入左值（如 `int a; func(a)`），`T` 推导为 `int&`，`T&&` 折叠为 `int&`（左值引用）。
    - 当传入右值（如 `func(10)`），`T` 推导为 `int`，`T&&` 就是 `int&&`（右值引用）。
2.  **`std::forward` 函数**：用于“还原”万能引用的原始类型。它只对用 `T&&` 接收的参数生效，根据 `T` 的推导结果，将参数转发为左值或右值。
    - 若 `T` 是左值引用（如传入左值），`std::forward<T>(param)` 转发为左值。
    - 若 `T` 是非引用类型（如传入右值），`std::forward<T>(param)` 转发为右值。


用代码理解：完美转发 vs 普通转发
假设我们有两个目标函数，分别接收左值和右值：
```cpp
// 接收左值
void target(int& x) {
    cout << "左值引用: " << x << endl;
}

// 接收右值
void target(int&& x) {
    cout << "右值引用: " << x << endl;
}
```

1. 普通转发（失败案例）
如果不用完美转发，模板函数无法保持参数属性：
```cpp
template <typename T>
void bad_forward(T param) {  // 按值传递，会拷贝，且丢失左/右值属性
    target(param);  // param 是变量（左值），永远调用 target(int&)
}

int a = 10;
bad_forward(a);    // 传入左值，调用 target(int&) → 看似对，但拷贝了参数
bad_forward(20);   // 传入右值，但 param 是左值，仍调用 target(int&) → 错误！
```


2. 完美转发（成功案例）
用万能引用 + `std::forward` 实现：
```cpp
template <typename T>
void perfect_forward(T&& param) {  // 万能引用，接收左/右值
    target(std::forward<T>(param));  // 完美转发，还原原始类型
}

int a = 10;
perfect_forward(a);    // 传入左值，T推导为int&，forward转发为左值 → 调用 target(int&)
perfect_forward(20);   // 传入右值，T推导为int，forward转发为右值 → 调用 target(int&&)
```
这就实现了“原封不动”的转发，和直接调用 `target(a)`、`target(20)` 的效果完全一致。


核心总结
- **完美转发 = 万能引用（`T&&`） + `std::forward<T>`**，二者必须配合使用。
- 目的：解决模板函数中参数传递时“属性丢失”的问题，确保目标函数能正确匹配左/右值重载。
- 记忆点：万能引用负责“接收所有类型”，`std::forward` 负责“还原原始类型”，像快递中转站一样，原样传递包裹的“易碎（右值）”或“普通（左值）”标签。


C++ 左值和右值



1. 左值-能放在赋值号左边的东西
假设你有个杯子，杯子里装着水。现在我问你：**“你能把‘水’倒进‘杯子’里，还是能把‘杯子’倒进‘水’里？”**  
答案显然是前者——因为「杯子」是一个「有固定位置、能被“装东西”」的容器；而「水」是「没有固定位置、倒出去就可能消失」的东西。

C++ 里的「左值」，就相当于这个「杯子」。它的核心特点是：**有自己的“内存地址”，能被赋值（放在 `=` 左边），也能被反复修改**。

举个最直观的例子：
```cpp
int a = 10;  // 这里的 a 就是左值
a = 20;      // 能再次赋值，没问题（杯子能重新装水）
```
为什么 `a` 是左值？因为 `a` 是一个「变量」——它在内存里占了一块固定的地方（比如地址 `0x1234`），我们能往这块地方里塞不同的数字（10、20……）。

再想一个场景：如果你有个函数返回「变量本身」，它也是左值。比如：
```cpp
int& get_num(int& x) {  // 返回值是“引用”（可以理解为“杯子的别名”）
    return x;
}

int b = 5;
get_num(b) = 100;  // 没问题！get_num(b) 返回的是 b 的别名（还是杯子），能放左边赋值
```
这里 `get_num(b)` 本质还是 `b` 这个“杯子”，所以它是左值。


2 右值-只能放在赋值号右边的东西
回到杯子的例子：「水」不能当容器，只能被“装进杯子”。C++ 里的「右值」，就相当于这「水」——它的核心特点是：**没有固定内存地址（或者说“临时存在”），不能被赋值（放 `=` 左边会报错），用完就可能被销毁**。

最典型的右值是「字面量」（比如 `10`、`3.14`、`"hello"`）：
```cpp
int c = 10;  // 这里的 10 就是右值
10 = 20;     // 报错！你不能把 20 塞进“10”里（水不能当杯子）
```
为什么 `10` 是右值？因为 `10` 不是变量——它是一个“临时的数值”，程序用它的时候，可能只在 CPU 寄存器里暂存一下，用完就没了，根本没有固定的内存地址，自然不能被赋值。

另一种常见的右值是「函数返回的临时值」：
```cpp
int add(int x, int y) {
    return x + y;  // 返回的是 x+y 的结果（临时值，不是变量）
}

int d = add(3, 5);  // 没问题！add返回的临时值（8）是右值，能放右边赋值
add(3, 5) = 10;     // 报错！临时值是右值，不能放左边
```
`add(3,5)` 计算出的 `8` 是个临时结果，不是任何变量，所以是右值，不能被赋值。

3. 区分左值和右值
前面的例子其实能总结出一个最简单的判断方法：**如果一个东西能被 `&`（取地址符）取到地址，它就是左值；反之就是右值**。

我们来验证一下：
- 左值 `a`：`&a` 能拿到地址（比如 `0x1234`）→ 左值。
- 右值 `10`：`&10` 会报错（临时值没有固定地址）→ 右值。
- 左值 `get_num(b)`：`&get_num(b)` 其实是 `&b`，能拿到地址 → 左值。
- 右值 `add(3,5)`：`&add(3,5)` 会报错（临时结果没地址）→ 右值。

这个测试几乎能覆盖 90% 的场景，记不住定义的时候，用它判断就够了。


### 第四步：关键延伸——为什么要区分左值和右值？
你可能会问：“我知道怎么区分了，但这玩意儿有啥用？”  
答案是：**为了“高效”和“安全”**——C++11 之后引入的「右值引用」（`&&`），就是基于左值和右值的区分，解决了“临时对象拷贝浪费性能”的问题。

举个例子：假设你有个函数返回一个很大的字符串（比如 10MB）：
```cpp
string get_big_string() {
    string temp = "非常长的字符串...";  // 临时对象 temp
    return temp;  // 返回 temp 的拷贝（传统方式会复制 10MB 数据，很慢）
}
```
在 C++11 之前，`get_big_string()` 返回的 `temp` 是右值（临时值），但程序会把它“拷贝”一份给接收变量，10MB 的数据拷贝一次很浪费。

但有了右值引用后，程序会发现：“哦，这个临时值（右值）用完就要销毁了，不如直接把它的‘资源’（内存）‘偷’过来用，不用拷贝了！” 这就是「移动语义」，能大幅提升性能。

而要实现“移动语义”，前提就是能区分「右值」（可以偷资源的临时对象）和「左值」（不能偷，否则原变量就废了）——这就是左值和右值区分的核心价值。


### 最后总结：一句话记住
- **左值**：是“容器”（有地址、能赋值、能取地址），比如变量、引用。
- **右值**：是“内容”（没地址、不能赋值、不能取地址），比如字面量、临时值。
- **判断口诀**：能取地址的是左值，不能的是右值。

下次写代码时，再遇到 `=` 两边的东西，或者 `&&` 引用，就用这个逻辑套一下，很快就能熟练了。