// 类
#include <iostream>
#include <string>
using namespace std;

/*
类 三大特征:
封装 继承 多态

class 类名{
访问权限：
    属性(成员变量)
    行为(成员函数)
}

访问权限:
私有权限 private  类内可以访问，类外不可以访问, 子类不可以访问
保护权限 protected 类内可以访问，类外不可以访问，子类可以访问
公共权限 public 类内可以访问，类外也可以访问

构造函数注意点
作用：在对象创建时自动调用，用于初始化对象的成员变量、分配资源（如内存、文件句柄等）。
1. 函数名称和类名一致
2. 函数返回值不用写
3. 可以被重载（定义多个参数不同的构造函数）。
4. 如果未显式定义，编译器会自动生成一个默认构造函数（无参数，不做任何操作）。



析构函数注意点
作用：在对象销毁时自动调用，用于释放对象占用的资源（如动态内存、关闭文件等），避免内存泄漏。
1.函数名称和类名一致，在前面添加一个~
2.函数返回值不用写
3.不能有参数
4.对象销毁时（如离开作用域、被 delete 释放）自动调用。
5.如果未显式定义，编译器会生成默认析构函数（不做任何操作）。



C++
类对象的生命周期会随其作用域或管理方式结束而终止，此时会主动调用析构函数，并非只有程序结束时才会调用析构函数。程序结束时调用析构函数，只是针对
“生命周期与程序一致” 的对象（如全局对象），而非所有对象。
要理解这个问题，核心是先明确 C++
类对象的三种常见生命周期场景，不同场景下析构函数的调用时机完全不同：
1. 局部对象：作用域结束时调用析构函数
定义在函数、代码块（如 if/for 内部）中的局部对象，其生命周期与 “所在的作用域”
绑定 ——离开作用域时，对象会自动销毁，析构函数立即调用，和程序是否结束无关。

2. 动态对象：delete 时调用析构函数
用 new 动态创建的对象（如 Test* t = new
Test()），其生命周期不绑定作用域，而是由程序员手动管理 ——只有调用 delete
时，对象才会销毁，析构函数才会调用；如果忘记
delete，就是内存泄漏（但程序结束时仍会被操作系统回收）。

3. 全局 / 静态对象：程序结束时调用析构函数
定义在函数外部的全局对象、或用 static
修饰的静态对象（包括局部静态对象），其生命周期与程序一致
——程序启动时创建，程序结束时才销毁，析构函数在此时调用。 这是唯一
“程序结束时才调用析构函数” 的场景，但仅针对这类特殊对象，并非所有对象。

*/

class Hero {

private:
  string _name;
  int hp;

public:
  Hero() { cout << "构造函数使用" << endl; };
  Hero(string name, int hp) : _name(name), hp(hp) { //初始化列表
    cout << "初始化列表使用" << endl;
  }

  Hero(string name) {
    _name = name;
    cout << "有参构造函数使用" << endl;
  }
  ~Hero() { cout << "析构函数使用" << endl; }

  Hero(const Hero &hero) {
    _name = hero._name;
    cout << "拷贝构造函数使用" << endl;
  }
};

int main() {
  Hero heroo;
  Hero hero("wangqi");
  Hero hero2("swen", 100);
  Hero hero1(hero);
  Hero *hero3 = new Hero(); // new一个类

  delete hero3;
  cout << "锚点" << endl; //锚点后，即程序结束前默认调用析构函数

  return 0;
}
